//===----------------------------------------------------------------------===//
// Copyright Â© 2024-2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//

/// Common settings for Pkl's own evaluator.
@ModuleInfo { minPklVersion = "0.31.0" }
@Since { version = "0.26.0" }
module pkl.EvaluatorSettings

import "pkl:EvaluatorSettings"

/// The external properties available to Pkl, read using the `prop:` scheme.
externalProperties: Mapping<String, String>?

/// The environment variables available to Pkl, read using the `env:` scheme.
///
/// Example:
/// ```
/// env {
///   ["IS_PROD"] = "true"
/// }
/// ```
env: Mapping<String, String>?

/// The set of module URI patterns that can be imported.
///
/// Each element is a regular expression pattern that is tested against a module import.
///
/// Modules are imported either through an amends or extends clause, an import clause, or an
/// import expression.
///
/// Example:
/// ```
/// allowedModules {
///   "https:"
///   "file:"
///   "package:"
///   "projectpackage:"
/// }
/// ```
allowedModules: Listing<String(isRegex)>?

/// The set of resource URI patterns that can be imported.
///
/// Each element is a regular expression pattern that is tested against a resource read.
///
/// Example:
/// ```
/// allowedResources {
///   "https:"
///   "file:"
///   "package:"
///   "projectpackage:"
///   "env:"
///   "prop:"
/// }
/// ```
allowedResources: Listing<String(isRegex)>?

/// When to format messages with ANSI color codes.
///
/// Possible values:
///
/// - `"never"`: Never format 
/// - `"auto"`: Format if the process' stdin, stdout, or stderr are connected to a console.
/// - `"always"`: Always format
@Since { version = "0.27.0" }
color: ("never" | "auto" | "always")?

/// Disables the file system cache for `package:` modules.
///
/// When caching is disabled, packages are loaded over the network and stored in memory.
noCache: Boolean?

/// A collection of jars, zips, or directories to be placed into the module path.
///
/// Module path modules and resources may be read and imported using the `modulepath:` scheme.
modulePath: Listing<String>?

/// The duration after which evaluation of a source module will be timed out.
///
/// Note that a timeout is treated the same as a program error in that any subsequent source modules will not be evaluated.
timeout: Duration?

/// The directory where `package:` modules are cached.
moduleCacheDir: String?

/// Restricts access to file-based modules and resources to those located under this directory.
rootDir: String?

/// Configuration of outgoing HTTP requests.
http: Http?

/// Configuration for external module reader processes.
@Since { version = "0.27.0" }
externalModuleReaders: Mapping<String, ExternalReader>?

/// Configuration for external resource reader processes.
@Since { version = "0.27.0" }
externalResourceReaders: Mapping<String, ExternalReader>?

/// Defines options for the formatting of calls to the trace() method.
///
/// Possible values:
///
/// - `"compact"`: All structures passed to trace() will be emitted on a single line.
/// - `"pretty"`: All structures passed to trace() will be indented and emitted across multiple lines.
@Since { version = "0.30.0" }
traceMode: ("compact" | "pretty")?

/// The enclosing URI used to resolve relative paths.
@Since { version = "0.31.0" }
hidden enclosingUri: String

local function resolvePath(base: String, path: String) =
  if (path.startsWith("/") || path.startsWith(Regex(#"([a-z]:)?\\"#)))
    path
  else
    "\(base)/\(path)"

local function resolveExecutable(base: String, path: String) =
  if (path.contains("/") || path.contains("\\"))
    resolvePath(base, path)
  else
    path

/// These evaluator settings, whose settings are resolved against [baseDir].
///
/// The following settings are resolved:
///
///   * [modulePath]
///   * [rootDir]
///   * [moduleCacheDir]
///   * [externalResourceReaders]
///   * [externalModuleReaders]
@Since { version = "0.31.0" }
function resolve(baseDir: String): EvaluatorSettings = (module) {
  when (module.modulePath != null) {
    modulePath = new {
      for (path in module.modulePath!!) {
        resolvePath(baseDir, path)
      }
    }
  }

  when (module.rootDir != null) {
    rootDir = resolvePath(baseDir, module.rootDir!!)
  }

  when (module.moduleCacheDir != null) {
    moduleCacheDir = resolvePath(baseDir, module.moduleCacheDir!!)
  }

  when (module.externalResourceReaders != null) {
    externalResourceReaders {
      for (readerName, reader in module.externalResourceReaders!!) {
        [readerName] {
          executable = resolveExecutable(baseDir, reader.executable)
        }
      }
    }
  }

  when (module.externalModuleReaders != null) {
    externalModuleReaders {
      for (readerName, reader in module.externalModuleReaders!!) {
        [readerName] {
          executable = resolveExecutable(baseDir, reader.executable)
        }
      }
    }
  }
}

local const hostnameRegex = Regex(#"https?://([^/?#]*)"#)

local const hasNonEmptyHostname = (it: String) ->
  let (hostname = hostnameRegex.findMatchesIn(it).getOrNull(0)?.groups?.getOrNull(1)?.value)
    hostname != null && hostname.length > 0

/// A key or value in [Http.rewrites].
@Since { version = "0.29.0" }
typealias HttpRewrite = String(startsWith(Regex("https?://")), endsWith("/"), hasNonEmptyHostname)

/// Settings that control how Pkl talks to HTTP(S) servers.
class Http {
  /// Configuration of the HTTP proxy to use.
  proxy: Proxy?

  /// Replace outbound requests from one URL with another URL.
  ///
  /// Each key describes the prefix of a request, and each value describes the replacement prefix.
  ///
  /// This can be useful for setting up mirroring of packages, which are fetched over HTTPS.
  ///
  /// In the case of multiple matches, the longest prefix is used.
  ///
  /// The URL hostname is case-insensitive.
  ///
  /// A replacement only happens once when resolving URLs.
  /// Therefore, the first replacement is the final URL that is used for the outbound request.
  ///
  /// In the following example, an original request for `https://pkg.pkl-lang.org/my/pkg@1.0.0` is
  /// replaced with `https://my.internal.mirror/my/pkg@1.0.0`.
  ///
  /// This does not affect `3XX` status code redirect following.
  ///
  /// Example:
  ///
  /// ```
  /// rewrites {
  ///   ["https://pkg.pkl-lang.org/"] = "https://my.internal.mirror/"
  /// }
  /// ```
  ///
  /// Rewrite targets must satisfy the following:
  ///
  /// * It starts with either `http://`, or `https://`.
  /// * It ends with `/`.
  /// * It has a non-empty hostname.
  ///
  /// An rewrite target should also not contain a query string or fragment component
  /// (not schematically enforced).
  @Since { version = "0.29.0" }
  rewrites: Mapping<HttpRewrite, HttpRewrite>?
}

/// Settings that control how Pkl talks to HTTP proxies.
class Proxy {
  /// The proxy to use for HTTP(S) connections.
  ///
  /// Only HTTP proxies are supported.
  /// The proxy address must start with `http://`, and can only contain a host and a port.
  /// If a port is omitted, it defaults to port `80`.
  ///
  /// Proxy authentication is not supported.
  ///
  /// Example:
  /// ```
  /// address = "http://my.proxy.example.com:5080"
  /// ```
  address: Uri(startsWith("http://"))?

  /// Hosts to which all connections should bypass a proxy.
  ///
  /// Values can be either hostnames, or IP addresses.
  /// IP addresses can optionally be provided using
  /// [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation).
  ///
  /// The value `"*"` is a wildcard that disables proxying for all hosts.
  ///
  /// A hostname matches all subdomains.
  /// For example, `example.com` matches `foo.example.com`, but not `fooexample.com`.
  /// A hostname that is prefixed with a dot matches the hostname itself,
  /// so `.example.com` matches `example.com`.
  ///
  /// Hostnames do not match their resolved IP addresses.
  /// For example, the hostname `localhost` will not match `127.0.0.1`.
  ///
  /// Optionally, a port can be specified.
  /// If a port is omitted, all ports are matched.
  ///
  /// Example:
  ///
  /// ```
  /// noProxy {
  ///   "127.0.0.1"
  ///   "169.254.0.0/16"
  ///   "example.com"
  ///   "localhost:5050"
  /// }
  /// ```
  noProxy: Listing<String>(isDistinct)
}

@Since { version = "0.27.0" }
class ExternalReader {
  /// The external reader executable.
  ///
  /// Will be spawned with the same environment variables and working directory as the Pkl process.
  /// This may be:
  ///
  ///   * An absolute path
  ///   * A relative path
  ///   * The name of the executable, to be resolved against the `PATH` environment variable 
  ///
  /// On Windows, it is acceptable to use either `\` or `/` as the path separator.
  ///
  /// A simple name without slashes (e.g. `"my-command"`) is resolved against the `PATH`
  /// environment variable, rather than against the enclosing directory.
  ///
  /// To resolve this as a path, prefix it with `./` (or `.\` on Windows).
  executable: String

  /// Additional command line arguments passed to the external reader process.
  arguments: Listing<String>?
}

/// Machiney for URI percent decoding.
// TODO: replace me when URI stdlib is introduced
@Unlisted
local class Impl {
  const percentDecode = (str: String) ->
    str.replaceAllMapped(PERCENT_REGEX, (match) ->
      let (bytes = getBytes(match.value))
        doPercentDecode(bytes)
    )

  local const PERCENT_REGEX = Regex(#"(?:%[\da-fA-F]{2})+"#)

  local const hexDigits = "0123456789ABCDEF"

  local const function getBytes(str: String): List<UInt8> =
    str
      .split("%")
      .drop(1)
      .map((it) ->
        let (msb = hexDigits.indexOf(it[0].toUpperCase()))
        let (lsb = hexDigits.indexOf(it[1].toUpperCase()))
          lsb + (msb * 16)
      )

  local const function doPercentDecode(bytes: List<UInt8>): String = _doPercentDecode(bytes, "")

  local const function _doPercentDecode(bytes: List<UInt8>, ret: String) =
    if (bytes.length == 0)
      ret
    else if (bytes[0] < 0x80)
      _doPercentDecode(bytes.drop(1), ret + bytes[0].toChar())
    else if (bytes[0] < 0xE0)
      let (b0 = bytes[0].and(0x1f).shl(6))
      let (b1 = bytes[1].and(0x3f))
        _doPercentDecode(bytes.drop(2), ret + b0.or(b1).toChar())
    else if (bytes[0] < 0xF0)
      let (b0 = bytes[0].and(0xf).shl(12))
      let (b1 = bytes[1].and(0x3f).shl(6))
      let (b2 = bytes[2].and(0x3f))
        _doPercentDecode(bytes.drop(3), ret + b0.or(b1).or(b2).toChar())
    else
      let (b0 = bytes[0].and(0x7).shl(18))
      let (b1 = bytes[1].and(0x3f).shl(12))
      let (b2 = bytes[2].and(0x3f).shl(6))
      let (b3 = bytes[3].and(0x3f))
        _doPercentDecode(bytes.drop(4), ret + b0.or(b1).or(b2).or(b3).toChar())
}
